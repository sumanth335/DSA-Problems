/*Time Complexity: O(NlogN), Space complexity: O(N)Approach: 	Step:1 Merge the overlapping intervals, returns sorted list of range	Step:2 Traverse linearly the range and find the kth element*/import java.util.*;class kth_SmallestAgain{	static class Interval{		int start, end;		Interval(int start, int end){			this.start = start;			this.end = end;		}	}	public static void main(String [] args){		Interval arr[]=new Interval[5];   	// array of Intervals		arr[0]=new Interval(6,8); 	//interval object is stord in arr[0]		arr[1]=new Interval(4,8); 		arr[2]=new Interval(3,4); 		arr[3]=new Interval(4,7); 		arr[4]=new Interval(11,12);		Stack<Interval> merged=mergeIntervals(arr); 		for(Interval i: merged)			System.out.print("["+i.start+","+i.end+"] "); 		int query[] = {5, 8};		for(int k: query)			System.out.print("\n"+kth_Smallest(merged,k));	}	static Stack<Interval> mergeIntervals(Interval arr[]){		Stack<Interval> merged = new Stack<Interval>();		//sort in ascending order according to 'start' value		Arrays.sort(arr, (i1, i2) -> i1.start-i2.start);		merged.push(arr[0]);		for(int i=1; i<arr.length; i++){			Interval top =merged.peek();						if(top.end<arr[i].start)				merged.push(arr[i]);			// there is overlapping if above statement is false			else if(top.end<arr[i].end){				top.end = arr[i].end;				merged.pop();				merged.push(top);			}		}	return merged;	}	static int kth_Smallest(Stack<Interval> merged, int k){		for(Interval i : merged){			if(k<= (i.end-i.start+1)){				return i.start+k-1;			}			else				k=k- (i.end-i.start+1);		}		return -1;	}}